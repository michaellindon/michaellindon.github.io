---
id: 463
title: Calling C++ from R using Rcpp
date: 2013-06-23T02:39:23+00:00
author: admin
layout: post
guid: http://www.lindonslog.com/?p=463
permalink: /programming/r/rcpp/
categories:
  - R
---
## Why call C/C++ from R?

I really like programming in R. The fact that it is open source immediately wins my favour over Matlab. It can, however, be quite slow especially if you &#8220;speak&#8221; R with a strong C/C++ accent. This sluggishness, especially when writing unavoidable for loops, has led me to consider other programming languages. I have come to the conclusion that there is no all-round best programming language but a combination of R and C++ is very hard to beat. My resolution is to write the expensive codes in C++ and to call them as functions within R so that I still have the nice dynamic interactivity of an R session with the speed and optimization of C++. There are 3 ways you can get started implementing C code in R, namely, &#8220;.C,&#8221;, &#8220;.Call&#8221; and Rcpp. It is generally not recommended to use &#8220;.C&#8221; but to use &#8220;.Call&#8221; instead. &#8220;.Call&#8221;, however, requires quite a bit of boilerplate code and can be tiresome and obfuscating to write. &#8220;Rcpp&#8221;, while not intrinsically part of R itself, is a package written by <a href="http://dirk.eddelbuettel.com/" rel="nofollow">D Eddelbuettel</a> and R Fran√ßois which relies on &#8220;.Call&#8221; but allows you to write neater more efficient code by providing an interface between &#8220;.Call&#8221; and the programmer. There are many things to consider when writing C++ code for R but most likely you will want to get coding as fast as possible and worry about these other tangential matters later.

## How to call C/C++ from R using Rcpp [The Hard/Conscientious Way]

_Note: This is the longest and hardest way to compile C++ code for R, but it is arguably the most flexible for the conscientious user who requires complex code and desires to know all the details of whats going on. For a simpler no-nonsense approach scroll down to the &#8220;sourceCpp&#8221; command._
  
Lets jump right in with an example

<pre class="brush: cpp; title: ; notranslate" title="">#include &lt;Rcpp.h&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;


using namespace std;
RcppExport SEXP comp(SEXP x, SEXP y){
        int i,n;
        Rcpp::NumericVector vector1(x);
        Rcpp::NumericVector vector2(y);
        n=vector2.size();
        Rcpp::NumericVector product(n);
for(i=0;i&lt;n;i++){
product[i]=vector1[i]*vector2[i];
}
return(product);
}
</pre>

_Note: You do not need R.h and Rdefines.h when you use Rcpp.h._
  
_Note: This is not the only way to compile and call code for R. See bottom for a neater alternative._
  
The function has two R objects as arguments, which are datatype &#8220;SEXP&#8221;, and returns an R object. The &#8220;SEXP&#8221; R objects, which are technically pointers to structures with typedef SEXPREC, are quite complex and so must be coerced into a vector using Rcpp::NumericVector, which makes a vector out of the SEXP object. Similarly, Rcpp::NumeriVector can be used to create a vector of length n. The rest is standard C++ code. Before compiling some compiler flags must be set:

<pre class="brush: bash; title: ; notranslate" title="">[michael@michael rcpp]$ export PKG_CXXFLAGS=`Rscript -e "Rcpp:::CxxFlags()"`
[michael@michael rcpp]$ export PKG_LIBS=`Rscript -e "Rcpp:::LdFlags()"`
</pre>

Compile with:

<pre class="brush: bash; title: ; notranslate" title="">[michael@michael rcpp]$ R CMD SHLIB comp.cpp
</pre>

The function is now ready to be used in R. Consider the following R code:

<pre class="brush: r; title: ; notranslate" title="">library(Rcpp)
dyn.load('comp.so')
x=rnorm(100,0,1)
y=rnorm(100,0,1)
.Call('comp',x,y)
</pre>

First the Rcpp library is loaded. Then, C++ code is loaded with &#8220;dyn.load&#8221;, after which it is ready to be used in R. The &#8220;.Call&#8221; function calls the &#8220;comp&#8221; function and the two arguments are supplied after. Now lets consider a more interesting example by parallelizing the C++ with openmp.

## Performance with OpenMP

<pre class="brush: cpp; title: ; notranslate" title="">#include &lt;Rcpp.h&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;omp.h&gt;

using namespace std;
RcppExport SEXP parad(SEXP x, SEXP y){
	int i,n,max;
	Rcpp::NumericVector vector1(x);
	Rcpp::NumericVector vector2(y);
	n=vector2.size();
	Rcpp::NumericVector product(n);
	max=omp_get_max_threads();
	omp_set_num_threads(max);

#pragma omp parallel for
for(i=0;i&lt;n;i++){
product[i]=vector1[i]/vector2[i];
}
return(product);
}
</pre>

The purpose of this code is rather trivial, just dividing each element of x by the corresponding element of y. Now the compiler must be told to link against the openmp libraries so to compile we write

<pre class="brush: bash; title: ; notranslate" title="">[michael@michael rcpp]$ export PKG_LIBS='`Rscript -e "Rcpp:::LdFlags()"` -fopenmp -lgomp'
[michael@michael rcpp]$ export PKG_CXXFLAGS='`Rscript -e "Rcpp:::CxxFlags()"` -fopenmp'
[michael@michael rcpp]$ R CMD SHLIB parad.cpp
</pre>

How does this fair against the standard R &#8220;x/y&#8221;? To compare the &#8220;rbenchmark&#8221; package will be used.

<pre class="brush: r; title: ; notranslate" title="">library(Rcpp)
library(rbenchmark)
dyn.load('unpar.so')
dyn.load('parad.so')

x=rnorm(10000000,0,1)
y=rnorm(10000000,0,1)
benchmark(replications=rep(1,0,1),.Call('unpar',x,y),.Call('parad',x,y),x/y)
</pre>

<pre class="brush: r; title: ; notranslate" title="">&gt; benchmark(replications=rep(1,0,1),.Call('unpar',x,y),.Call('parad',x,y),x/y)
                  test replications elapsed relative user.self sys.self
2   .Call("parad", x, y)            1   0.036    1.000     0.112    0.002
1 .Call("unpar", x, y)            1   0.082    2.278     0.081    0.000
3                  x/y            1   0.053    1.472     0.048    0.005
</pre>

The parallel version of the x-divided-by-y code is even faster than R&#8217;s native &#8220;x/y&#8221;.

## Converting between C++ and R datatypes using &#8220;as&#8221; and &#8220;wrap&#8221;

If you feel more comfortable seeing familiar C/C++ variable types, one is free to convert all of the function arguments of SEXP type to the desired C++ variable types for use in the body of the code and then to convert them back to SEXP at the end before returning the function. Say, for example, that I have a vector of 100 standard normal draws as one might obtain from x=rnorm(100,0,1). Passing x as an argument to the C++ function and the variable type of x is SEXP. I can then convert it to a vector of doubles using the **&#8220;as&#8221;** command, perform any processing with it in the body of the function and then convert it back to SEXP at the end using the **&#8220;wrap&#8221;** command. Here is a short example:

<pre class="brush: r; title: ; notranslate" title="">#include &lt;Rcpp.h&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;
RcppExport SEXP conv(SEXP x, SEXP y){
	int i,n;
	vector&lt;double&gt; vector1=Rcpp::as&lt;vector&lt;double&gt; &gt;(x);
	vector&lt;double&gt; vector2=Rcpp::as&lt;vector&lt;double&gt; &gt;(y);
n=vector1.size();
vector&lt;double&gt; product(n);

for(i=0;i&lt;n;i++){
product[i]=vector1[i]/vector2[i];
}
return( Rcpp::wrap(product) );
}
</pre>

The x and y SEXP&#8217;s are converted to vector doubles and then converted back at the end. I like this approach because my function remains looking like C++.

## Streamlined sourceCpp() and cppFunction()

It is not necessary to compile, link and load the C++ code as above. There exist some wrappers for all of these tasks such as **include, sourceCpp and cppFunction**. I like sourceCpp() the best. Consider the C++ code stored in parad.cpp shown below:

<pre class="brush: r; title: ; notranslate" title="">#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;Rcpp.h&gt;
#include &lt;omp.h&gt;

using namespace std;
// [[Rcpp::export]]
Rcpp::NumericVector parad(Rcpp::NumericVector x, Rcpp::NumericVector y){
	int i,n,max;
	n=x.size();
	Rcpp::NumericVector product(n);
	max=omp_get_max_threads();
	omp_set_num_threads(max);

#pragma omp parallel for
for(i=0;i&lt;n;i++){
product[i]=x[i]/y[i];
}
return(product);
}
</pre>

This is a neat little parallel C++ function. This can be compiled, linked and loaded in one step using the sourceCpp() function. All we need to do is set some terminal environment variables for the compiler to use openMP.

<pre class="brush: bash; title: ; notranslate" title="">library(Rcpp)
Sys.setenv("PKG_CXXFLAGS"="-fopenmp")
Sys.setenv("PKG_LIBS"="-fopenmp")
sourceCpp("parad.cpp")
a=rnorm(1000,0,1)
b=rnorm(1000,0,1)
c=parad(a,b)
</pre>

Lines 2 and 3 are simply setting terminal environment variables from within R so that the compiler compiles as &#8220;g++ &#8230;. -fopenmp &#8230;&#8221; which we need for the &#8220;omp.h&#8221; header. sourceCpp is a wrapper that takes care of everything. After that one can immediately start using the parad() function.