{
    "docs": [
        {
            "location": "/",
            "text": "Introduction to sss4clj\n\n\nShotgun Stochastic Search is an algorithm for maximizing functions {0,1}\u1d3e \u2192 \u211d described in \nShotgun Stochastic Search for \u201cLarge p\u201d Regression\n.\nThe philosophy of sss4clj is \"less is more\". Rather than provide a monolithic library that supplies a unique function for all possible optimization problems, sss4clj provides a minimal set of very general composable functions, which the user can combine to apply to any specific case. Essentially to use this package the user must only supply a function that maps a set to a double. Each element a \u2208 {0,1}\u1d3e can be uniquely identified by an \"active set\" i.e. {i \u2208 \u2115| a\u1d62 = 1}. This project makes the design choice to work with the latter. sss4clj runs on the JVM so is consequently fast and completely interoperable with other JVM hosted languages commonly used in production (Java, Scala, Groovy etc...). This code has also been used successfully as a service for R, communicating with the R process via sockets. Details on how to achieve that can be obtained \nhere\n. There is also a \ngithub\n page for this project, please file any issues or pull requests thereunder. \n\n\nWhy Clojure?\n\n\nClojure is a modern dialect of Lisp, hosted on the JVM, with full support for functional programming. Functional programs, avoiding mutability of named values, are much easier to reason about compared to their iterative counterparts by virtue of referential transparency and the substitution model of evaluation. Functional programming is an alternative to object oriented programming as a solution to the expression problem, in particular, functional languages allow the programmer to reach a higher level of abstraction, resulting more generic code and more code reuse. However, whilst Clojure is a predominantly functional language with persistant datastructures by default, it does allow the user to break purity (unlike Haskell) if performance is an issue. Clojure is, however, already a fast programming language as comparisons with C++ on the languages benchmark \nshow\n.  Being hosted on the JVM is also a great advantage, a widely tested and industry adopted platform, allowing total interoperability with Java and the libraries that come with it. As a result, industry programmers can incorporate sss4clj into their production code with ease. On the other hand, Clojure is dynamically typed and has a REPL, making it a very familiar workflow to individual users of languages such as R or Julia. Another functional language on the JVM is Scala which is also very popular, so why not Scala? Two of the most notable differences are that Scala is still very much influenced by object oriented programming whereas Clojure eschews this approach and Scala is statically typed whereas Clojure is dynamically typed. This is down to preference. If you find that creating classes for everything makes your code overly complex, you may prefer clojure. Statically typed languages may catch errors sooner than those dynamically typed (at compile time rather that run time), but requires type annotations everywhere, increasing the amount of ceremony required to interact with the language. Both have their advantages.\n\n\nInstallation with Leiningen\n\n\nAdd the following dependency in your project.clj file\n\n\n\n\nAcknowledgements\n\n\nThis material was based upon work partially supported by the National Science Foundation under Grant DMS-1127914 to the Statistical and Applied Mathematical Sciences Institute. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation.\n\n\nLicense\n\n\nCopyright \u00a9 2017 Michael Lindon\n\n\nDistributed under the Eclipse Public License either version 1.0",
            "title": "Home"
        },
        {
            "location": "/#introduction-to-sss4clj",
            "text": "Shotgun Stochastic Search is an algorithm for maximizing functions {0,1}\u1d3e \u2192 \u211d described in  Shotgun Stochastic Search for \u201cLarge p\u201d Regression .\nThe philosophy of sss4clj is \"less is more\". Rather than provide a monolithic library that supplies a unique function for all possible optimization problems, sss4clj provides a minimal set of very general composable functions, which the user can combine to apply to any specific case. Essentially to use this package the user must only supply a function that maps a set to a double. Each element a \u2208 {0,1}\u1d3e can be uniquely identified by an \"active set\" i.e. {i \u2208 \u2115| a\u1d62 = 1}. This project makes the design choice to work with the latter. sss4clj runs on the JVM so is consequently fast and completely interoperable with other JVM hosted languages commonly used in production (Java, Scala, Groovy etc...). This code has also been used successfully as a service for R, communicating with the R process via sockets. Details on how to achieve that can be obtained  here . There is also a  github  page for this project, please file any issues or pull requests thereunder.",
            "title": "Introduction to sss4clj"
        },
        {
            "location": "/#why-clojure",
            "text": "Clojure is a modern dialect of Lisp, hosted on the JVM, with full support for functional programming. Functional programs, avoiding mutability of named values, are much easier to reason about compared to their iterative counterparts by virtue of referential transparency and the substitution model of evaluation. Functional programming is an alternative to object oriented programming as a solution to the expression problem, in particular, functional languages allow the programmer to reach a higher level of abstraction, resulting more generic code and more code reuse. However, whilst Clojure is a predominantly functional language with persistant datastructures by default, it does allow the user to break purity (unlike Haskell) if performance is an issue. Clojure is, however, already a fast programming language as comparisons with C++ on the languages benchmark  show .  Being hosted on the JVM is also a great advantage, a widely tested and industry adopted platform, allowing total interoperability with Java and the libraries that come with it. As a result, industry programmers can incorporate sss4clj into their production code with ease. On the other hand, Clojure is dynamically typed and has a REPL, making it a very familiar workflow to individual users of languages such as R or Julia. Another functional language on the JVM is Scala which is also very popular, so why not Scala? Two of the most notable differences are that Scala is still very much influenced by object oriented programming whereas Clojure eschews this approach and Scala is statically typed whereas Clojure is dynamically typed. This is down to preference. If you find that creating classes for everything makes your code overly complex, you may prefer clojure. Statically typed languages may catch errors sooner than those dynamically typed (at compile time rather that run time), but requires type annotations everywhere, increasing the amount of ceremony required to interact with the language. Both have their advantages.",
            "title": "Why Clojure?"
        },
        {
            "location": "/#installation-with-leiningen",
            "text": "Add the following dependency in your project.clj file",
            "title": "Installation with Leiningen"
        },
        {
            "location": "/#acknowledgements",
            "text": "This material was based upon work partially supported by the National Science Foundation under Grant DMS-1127914 to the Statistical and Applied Mathematical Sciences Institute. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation.",
            "title": "Acknowledgements"
        },
        {
            "location": "/#license",
            "text": "Copyright \u00a9 2017 Michael Lindon  Distributed under the Eclipse Public License either version 1.0",
            "title": "License"
        },
        {
            "location": "/usage/",
            "text": "Base Usage\n\n\nA single one-function-does-all is provided with \"run-sss\". However,\nin order to get the most from this package, the reader may be interested\nin the idividual functions that are composed to create run-sss. If not,\nthe user can skip down to the end of this page to run-sss. A minimal set of information\nthat the user must provide are \n\n\n\n\n\n\nA function that maps a set of integers to a double (the objective).\n\n\n\n\n\n\nAn initial set of integers to seed the algorithm (an empty set is also fine).\n\n\n\n\n\n\nA search space, namely, a set of all possible integers relevant to the problem (usually the set of integers from 1 to p where p is the dimension of the problem).\n\n\n\n\n\n\nNumber of iterations to run sss.\n\n\n\n\n\n\nNumber of top models to keep track (only an issue for long runs with memory constraints. In order\nto receive all visited models and their objective values, simply set this value large).\n\n\n\n\n\n\nWorked examples can also be found using the sidebar to the left.\n\n\nLeiningen Dependency\n\n\nAdd the following dependency in your project.clj file\n\n\n\n\nNamespaces\n\n\nOne must import functions provided by this package to the relevant namespace i.e.\n\n\n(ns myproject.core\n  (:require [sss4clj.core :refer :all]))\n\n\n\n\nVisiting Neighbours\n\n\nLets define an initial set A and a search space \u03a9 such that Let A \u2286 \u03a9 \u2282 \u2115.\n\n\n(def A #{0 3 4})\n(def Omega #{0 1 2 3 4})\n\n\n\n\nUse \ndrop-1\n to get all sets formed by removing 1 element.\n\n\n(drop-1 A)\n=> (#{4 3} #{0 3} #{0 4})\n\n\n\n\ndrop-1\n of empty set is considered empty.\n\n\n(drop-1 #{})\n=> ()\n\n\n\n\nUse \nadd-1\n to get all sets formed from the union of A with one element of \u03a9\\A.\n\n\n(add-1 Omega A)\n=> (#{0 1 4 3} #{0 4 3 2})\n\n\n\n\nadd-1\n of Omega is considered empty.\n\n\n(add-1 Omega Omega)\n=> ()\n\n\n\n\nUse \nswap-1\n to get all sets formed from exchanging one element of A with one element of its \u03a9\\A.\n\n\n(swap-1 Omega A)\n=> (#{1 4 3} #{0 1 3} #{0 1 4} #{4 3 2} #{0 3 2} #{0 4 2})\n\n\n\n\nUse \nneighbours\n to obtain all such sets formed form \ndrop-1\n, \nadd-1\n and \nswap-1\n operations.\n\n\n(neighbours Omega A)\n=> [(#{4 3} #{0 3} #{0 4}) (#{0 1 4 3} #{0 4 3 2}) (#{1 4 3} #{0 1 3} #{0 1 4} #{4 3 2} #{0 3 2} #{0 4 2})]\n\n\n\n\nObjective Function\n\n\nTo illustrate the next sss4clj functions we need a mathematical objective function that maps sets A \u2286 \u03a9 to R.\nTo do this lets just zip all sets in the power set of \u03a9 with a random uniform and convert to a function.\n\n\n(def subvalues (into (hash-map) (map vector (map #(set %) (combo/subsets (into (vector) Omega))) (repeatedly #(rand)))))\n(defn objective [x] (subvalues x))\n\n\n\n\nobjective\n is now the function which we will try to maximize.\n\n\n(objective #{})\n=> 0.5809422699383645\n(objective Omega)\n=> 0.37949346847568177\n(objective A)\n=> 0.1971199058962515\n\n\n\n\nPriority Map\n\n\nadd-priority-map\n returns a new function that on the surface is identical to objective,\n\n\n(def max-count 2)\n(def score (add-priority-map objective max-count))\n(score #{})\n=> 0.5809422699383645\n\n\n\n\nbut \nscore\n has a priority-map appended to its meta-data for the purposes of recording and tracking the best values so far.\n\n\n(deref (:scoreboard (meta score)))\n=> {#{} 0.5809422699383645}\n\n\n\n\nsss may run for a long time and so optionally the user may only want to keep track of the top \nmax-count\n vals in memory.\nThis is the purpose of the priority map.\n\n\n(objective A)\n=> 0.1971199058962515\n(deref (:scoreboard (meta score)))\n=> {#{0 4 3} 0.1971199058962515, #{} 0.5809422699383645}\n(score Omega)\n=> 0.37949346847568177\n(deref (:scoreboard (meta score)))\n=> {#{0 1 4 3 2} 0.37949346847568177, #{} 0.5809422699383645}\n\n\n\n\nOnce the size of the priority-map becomes large than max-count it drops the key-value pair with the smallest value. In the\nprevious example the key-value pair with key A was dropped.\n\n\nIterating SSS\n\n\nGiven a score function, an initial set A, and \u03a9, the user can perform one iteration of sss\n\n\n(next-model score Omega A)\n=> #{0 4 2}\n\n\n\n\nThe output is a new model, but one can check the sets visited within the iteration by dereferencing the meta-data of score\n\n\n(deref (:scoreboard (meta score)))\n=> {#{0 3 2} 0.8143170162925805, #{0 4} 0.8948151339032558}\n\n\n\n\nrun-sss\n\n\nAlternatively, the user can abstract the fine-grained details\nof the implementation and call a one function do-all\nThis returns the final scoreboard of sets visited after\n100 iterations of sss with a max-count of 5\n\n\n(run-sss objective Omega 100 5)\n=> {#{0 1 4 3} 0.8108222058800102, #{0 3 2} 0.8143170162925805, #{0 4} 0.8948151339032558, #{0} 0.951193987214408, #{1} 0.9658085016841405}\n\n\n\n\nCopyright \u00a9 2017 Michael Lindon\n\n\nDistributed under the Eclipse Public License either version 1.0",
            "title": "Base Usage"
        },
        {
            "location": "/usage/#base-usage",
            "text": "A single one-function-does-all is provided with \"run-sss\". However,\nin order to get the most from this package, the reader may be interested\nin the idividual functions that are composed to create run-sss. If not,\nthe user can skip down to the end of this page to run-sss. A minimal set of information\nthat the user must provide are     A function that maps a set of integers to a double (the objective).    An initial set of integers to seed the algorithm (an empty set is also fine).    A search space, namely, a set of all possible integers relevant to the problem (usually the set of integers from 1 to p where p is the dimension of the problem).    Number of iterations to run sss.    Number of top models to keep track (only an issue for long runs with memory constraints. In order\nto receive all visited models and their objective values, simply set this value large).    Worked examples can also be found using the sidebar to the left.",
            "title": "Base Usage"
        },
        {
            "location": "/usage/#leiningen-dependency",
            "text": "Add the following dependency in your project.clj file",
            "title": "Leiningen Dependency"
        },
        {
            "location": "/usage/#namespaces",
            "text": "One must import functions provided by this package to the relevant namespace i.e.  (ns myproject.core\n  (:require [sss4clj.core :refer :all]))",
            "title": "Namespaces"
        },
        {
            "location": "/usage/#visiting-neighbours",
            "text": "Lets define an initial set A and a search space \u03a9 such that Let A \u2286 \u03a9 \u2282 \u2115.  (def A #{0 3 4})\n(def Omega #{0 1 2 3 4})  Use  drop-1  to get all sets formed by removing 1 element.  (drop-1 A)\n=> (#{4 3} #{0 3} #{0 4})  drop-1  of empty set is considered empty.  (drop-1 #{})\n=> ()  Use  add-1  to get all sets formed from the union of A with one element of \u03a9\\A.  (add-1 Omega A)\n=> (#{0 1 4 3} #{0 4 3 2})  add-1  of Omega is considered empty.  (add-1 Omega Omega)\n=> ()  Use  swap-1  to get all sets formed from exchanging one element of A with one element of its \u03a9\\A.  (swap-1 Omega A)\n=> (#{1 4 3} #{0 1 3} #{0 1 4} #{4 3 2} #{0 3 2} #{0 4 2})  Use  neighbours  to obtain all such sets formed form  drop-1 ,  add-1  and  swap-1  operations.  (neighbours Omega A)\n=> [(#{4 3} #{0 3} #{0 4}) (#{0 1 4 3} #{0 4 3 2}) (#{1 4 3} #{0 1 3} #{0 1 4} #{4 3 2} #{0 3 2} #{0 4 2})]",
            "title": "Visiting Neighbours"
        },
        {
            "location": "/usage/#objective-function",
            "text": "To illustrate the next sss4clj functions we need a mathematical objective function that maps sets A \u2286 \u03a9 to R.\nTo do this lets just zip all sets in the power set of \u03a9 with a random uniform and convert to a function.  (def subvalues (into (hash-map) (map vector (map #(set %) (combo/subsets (into (vector) Omega))) (repeatedly #(rand)))))\n(defn objective [x] (subvalues x))  objective  is now the function which we will try to maximize.  (objective #{})\n=> 0.5809422699383645\n(objective Omega)\n=> 0.37949346847568177\n(objective A)\n=> 0.1971199058962515",
            "title": "Objective Function"
        },
        {
            "location": "/usage/#priority-map",
            "text": "add-priority-map  returns a new function that on the surface is identical to objective,  (def max-count 2)\n(def score (add-priority-map objective max-count))\n(score #{})\n=> 0.5809422699383645  but  score  has a priority-map appended to its meta-data for the purposes of recording and tracking the best values so far.  (deref (:scoreboard (meta score)))\n=> {#{} 0.5809422699383645}  sss may run for a long time and so optionally the user may only want to keep track of the top  max-count  vals in memory.\nThis is the purpose of the priority map.  (objective A)\n=> 0.1971199058962515\n(deref (:scoreboard (meta score)))\n=> {#{0 4 3} 0.1971199058962515, #{} 0.5809422699383645}\n(score Omega)\n=> 0.37949346847568177\n(deref (:scoreboard (meta score)))\n=> {#{0 1 4 3 2} 0.37949346847568177, #{} 0.5809422699383645}  Once the size of the priority-map becomes large than max-count it drops the key-value pair with the smallest value. In the\nprevious example the key-value pair with key A was dropped.",
            "title": "Priority Map"
        },
        {
            "location": "/usage/#iterating-sss",
            "text": "Given a score function, an initial set A, and \u03a9, the user can perform one iteration of sss  (next-model score Omega A)\n=> #{0 4 2}  The output is a new model, but one can check the sets visited within the iteration by dereferencing the meta-data of score  (deref (:scoreboard (meta score)))\n=> {#{0 3 2} 0.8143170162925805, #{0 4} 0.8948151339032558}",
            "title": "Iterating SSS"
        },
        {
            "location": "/usage/#run-sss",
            "text": "Alternatively, the user can abstract the fine-grained details\nof the implementation and call a one function do-all\nThis returns the final scoreboard of sets visited after\n100 iterations of sss with a max-count of 5  (run-sss objective Omega 100 5)\n=> {#{0 1 4 3} 0.8108222058800102, #{0 3 2} 0.8143170162925805, #{0 4} 0.8948151339032558, #{0} 0.951193987214408, #{1} 0.9658085016841405}  Copyright \u00a9 2017 Michael Lindon  Distributed under the Eclipse Public License either version 1.0",
            "title": "run-sss"
        },
        {
            "location": "/subsets/",
            "text": "Example: Best Subset Selection\n\n\nBy way of introduction consider the best subset selection problem. By this\nI mean minimizing the residual sum of squares subject to a cardinality constraint\non the support of the regression coefficients. Lets say that the zero norm\nof the regression coefficients must be less than an integer k, for which\nI will assign 5 for this problem.\n\n\nGenerate Some Data\n\n\nLets generate some data with which to illustrate the application of sss to\nthe best subset selection problem.\n\n\n(ns best-subset.core\n  (:require [clojure.core.matrix :refer :all]\n            [distributions.core :refer :all]\n            [sss4clj.core :refer :all]\n            [clojure.core.matrix.linear :as la]))\n\n\n(def n 200)\n(def p 20)\n(def X (reshape (sample (normal 0 1) (* n p)) [n p]))\n(def B (matrix (for [i (range 0 p)] (if (< i 4) i 0))))\n(def Y (add (mmul X B) (sample (normal 0 1) n)))\n\n\n\n\nRunning Shotgun Stochastic Search\n\n\nNote that sss requires that we sample a new state, for which the probability\nof being sampled is some function of the objective function. In this context\nwe want models with a low residual sum of squares to have a high probability\nof being sampled. For this reason we take the objective function to the \nexponential of the negative RSS with some scaling. We also set the probability\nto zero if the cardinality constraint is broken.\n\n\n(defn RSS [g]\n  (if (empty? g)\n    (dot Y Y)\n    (let [p-g (count g)\n          X-g (transpose (reshape (flatten (map #(mget (columns X) %) g)) [p-g n]))\n          proj (mmul X-g (la/solve (mmul (transpose X-g) X-g)) (transpose X-g))\n          orth-proj (sub (identity-matrix n) proj)]\n      (dot Y (mmul orth-proj Y)))))\n\n(def k 5)\n\n(defn objective [g]\n  (if (> (count g) k) 0 (exp (negate (/ (RSS g) n)))))\n\n\n(def Omega (into #{} (range 0 p)))\n(def top-subsets (run-sss objective #{} Omega 10 5))\n\n\n\n\nNote Omega is the the set containing integers from 0 to p-1 corresponding\nto all possible values of the active subset of regression coefficients.\nIn order to run sss we specify the previously defined objective, an initial\nset (the emtpy set in this example), Omega, the number of iterations to run\nand the top number of models discovered. The latter is only really an issue\nfor long runs with memory constraints. If you want to see all the models visited,\nthen just set this to be a really large interger.\n\n\n{#{1 4 3 2 16} 0.36936833972859484, #{1 3 12 2 9} 0.36940132623186667, #{1 6 3 12 2} 0.37143277613460907, #{1 3 12 2 5} 0.3772822611159165, #{1 3 12 2 16} 0.37729521913614006}\n\n\n\n\nCopyright \u00a9 2017 Michael Lindon\n\n\nDistributed under the Eclipse Public License either version 1.0",
            "title": "Best Subset Selection"
        },
        {
            "location": "/subsets/#example-best-subset-selection",
            "text": "By way of introduction consider the best subset selection problem. By this\nI mean minimizing the residual sum of squares subject to a cardinality constraint\non the support of the regression coefficients. Lets say that the zero norm\nof the regression coefficients must be less than an integer k, for which\nI will assign 5 for this problem.",
            "title": "Example: Best Subset Selection"
        },
        {
            "location": "/subsets/#generate-some-data",
            "text": "Lets generate some data with which to illustrate the application of sss to\nthe best subset selection problem.  (ns best-subset.core\n  (:require [clojure.core.matrix :refer :all]\n            [distributions.core :refer :all]\n            [sss4clj.core :refer :all]\n            [clojure.core.matrix.linear :as la]))\n\n\n(def n 200)\n(def p 20)\n(def X (reshape (sample (normal 0 1) (* n p)) [n p]))\n(def B (matrix (for [i (range 0 p)] (if (< i 4) i 0))))\n(def Y (add (mmul X B) (sample (normal 0 1) n)))",
            "title": "Generate Some Data"
        },
        {
            "location": "/subsets/#running-shotgun-stochastic-search",
            "text": "Note that sss requires that we sample a new state, for which the probability\nof being sampled is some function of the objective function. In this context\nwe want models with a low residual sum of squares to have a high probability\nof being sampled. For this reason we take the objective function to the \nexponential of the negative RSS with some scaling. We also set the probability\nto zero if the cardinality constraint is broken.  (defn RSS [g]\n  (if (empty? g)\n    (dot Y Y)\n    (let [p-g (count g)\n          X-g (transpose (reshape (flatten (map #(mget (columns X) %) g)) [p-g n]))\n          proj (mmul X-g (la/solve (mmul (transpose X-g) X-g)) (transpose X-g))\n          orth-proj (sub (identity-matrix n) proj)]\n      (dot Y (mmul orth-proj Y)))))\n\n(def k 5)\n\n(defn objective [g]\n  (if (> (count g) k) 0 (exp (negate (/ (RSS g) n)))))\n\n\n(def Omega (into #{} (range 0 p)))\n(def top-subsets (run-sss objective #{} Omega 10 5))  Note Omega is the the set containing integers from 0 to p-1 corresponding\nto all possible values of the active subset of regression coefficients.\nIn order to run sss we specify the previously defined objective, an initial\nset (the emtpy set in this example), Omega, the number of iterations to run\nand the top number of models discovered. The latter is only really an issue\nfor long runs with memory constraints. If you want to see all the models visited,\nthen just set this to be a really large interger.  {#{1 4 3 2 16} 0.36936833972859484, #{1 3 12 2 9} 0.36940132623186667, #{1 6 3 12 2} 0.37143277613460907, #{1 3 12 2 5} 0.3772822611159165, #{1 3 12 2 16} 0.37729521913614006}  Copyright \u00a9 2017 Michael Lindon  Distributed under the Eclipse Public License either version 1.0",
            "title": "Running Shotgun Stochastic Search"
        }
    ]
}